배경 : orphanRemoval = true를 설정해줬는데 

오류 :

`@OneToMany(mappedBy = "match", cascade = CascadeType.*ALL*/*, orphanRemoval = true*/)`

이런식으로 ManyToMany관계를 설정해줄때 자주 사용하게되는데

casecade는 부모의 작업(연관관계)이 자식에도 영향을 미치게한다.

orphanRemoval = true는 부모엔티티가 제거될 때 자식엔티티도 삭제해주는 즉 고아객체? 에대한 실질적으로 db에서 삭제를 해주는 로직이다.

그러나 삭제로직시에 오류가 계속 발생하였다.

결론 :

 1.  

orphanRemoval = true 적용하면 어찌되었든 

다른 객체 즉 match면 seat에서 seat이면 match에서 

서로 저장되는 정보가 다르니까 영향을 미치게 되면

 만약 match에서 저걸 사용하면 seat에서는 matchSeat이라는 중간엔티티가 남아있으니까 사라져야 하는 match 정보가 남겨져 있어서 안되고 반대상황이어도 마찬가지며 오류가 생길 수 밖에 없다.

2.

과연 다른사람들은 이코드를 보고 로직이 어떻게 돌아가나 알 수 있을까? 

알 수 있더라도 로직이 복잡해지면 복잡 할 수록 다른사람이 코드를 건드리기가 어려울것이다.( 만약에 1번같은 상황을 고려해서 만들었다 치더라도 다른 사람에게 말하지 않는 이상 찾기 굉장히 어려울것 )

즉 1,2번같은 상황을 해결하기 위해 코드를 수정했다.

결론 :

orphanRemoval = true 를 사용안하고, 1번의 오류와 2번의 가시성을 위해 서비스,레포지토리 단에서 설정해주었다,

![스크린샷 2025-08-27 오후 6.14.53.png](attachment:34c075cc-e0d9-4476-ac79-ed003014c7b5:스크린샷_2025-08-27_오후_6.14.53.png)

![스크린샷 2025-08-27 오후 6.15.03.png](attachment:feb34cc6-0c41-4e73-95db-efd732b21d8c:스크린샷_2025-08-27_오후_6.15.03.png)

//Match의 정보를 삭제하기 전에 연관되어있는 MatchSeatRepository의 match의 id를 삭제해줌으로서 객체가 db에 남아있는걸 방지한다.

![스크린샷 2025-08-27 오후 6.14.58.png](attachment:46def99e-c4b5-4243-aed0-c891f46b4d0e:스크린샷_2025-08-27_오후_6.14.58.png)

// orphanRemoval = true 적용 x

![스크린샷 2025-08-27 오후 6.16.43.png](attachment:b4c7222e-c8d0-4074-b396-9c9b33592b85:스크린샷_2025-08-27_오후_6.16.43.png)

//@OneToMany 관계는 데이터베이스에 외래 키가 없고, JPA가 자동으로 양쪽을 동기화해주지 않기에, 이렇게 코드를 만들어 줘야한다.

(즉, MatchSeat에서 create하는 과정에서 생긴 정보를 match나seat에 전달을 해주는 로직이 필요하고 그 로직을 matchseat에다 설정하는것)
